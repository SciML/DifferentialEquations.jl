"""
ConvergenceSimulation

A type which holds the data from a convergence simulation.

### Fields

* `solutions::Array{DESolution}`: Holds all the PdeSolutions.
* `h1Errors`: Vector of the H1 errors.
* `l2Errors`: Vector of the L2 errors.
* `maxErrors`: Vector of the nodal maximum errors.
* `node2Errors`: Vector of the nodal l2 errors.
* `N`: The number of simulations.
* `Œîts`: The Œît's in the simulations.
* `Œîxs`: The Œîx's in the simulations.
* `Œºs`: The CFL Œº's in the simulations.
* `ŒΩs`: The CFL ŒΩ's in the simulations.
* `ConvEst_h1`: The H1 error order of convergence estimate for the convergence simulation.
Generated via `log2(error[i+1]/error[i])`. Thus only valid if generated by halving/doubling
the Œît/Œîx. If alternate scaling, modify by dividing of log(base,ConvEst_h1)
* `ConvEst_l2`: The L2 error order of convergence estimate for the convergence simulation.
Generated via `log2(error[i+1]/error[i])`. Thus only valid if generated by halving/doubling
the Œît/Œîx. If alternate scaling, modify by dividing of log(base,ConvEst_l2)
* `ConvEst_max`: The nodal maximum error order of convergence estimate for the convergence simulation.
Generated via `log2(error[i+1]/error[i])`. Thus only valid if generated by halving/doubling
the Œît/Œîx. If alternate scaling, modify by dividing of log(base,ConvEst_max)
* `ConvEst_node2`: The nodal l2 error order of convergence estimate for the convergence simulation.
Generated via `log2(error[i+1]/error[i])`. Thus only valid if generated by halving/doubling
the Œît/Œîx. If alternate scaling, modify by dividing of log(base,ConvEst_node2)

"""
type ConvergenceSimulation
  solutions::Array{DESolution}
  errors
  N
  auxData
  ùí™est
  function ConvergenceSimulation(solutions::Array{DESolution};auxData=nothing)
    N = size(solutions,1)
    errors = Dict() #Should add type information
    for k in keys(solutions[1].errors)
      errors[k] = reshape(Float64[sol.errors[k] for sol in solutions],size(solutions)...)
    end
    ùí™est = Dict(map(calcùí™estimates,errors))
    return(new(solutions,errors,N,auxData,ùí™est))
  end
end

function testConvergence(Œîts::AbstractArray,prob::SDEProblem;T=1,numMonte=10000,fullSave=true)
  N = length(Œîts)
  solutions = DESolution[solve(prob::SDEProblem,Œîts[i],T,fullSave=fullSave) for j=1:numMonte,i=1:N]
  auxData = Dict("Œîts" =>  Œîts)
  ConvergenceSimulation(solutions,auxData=auxData)
end

function testConvergence(Œîts::AbstractArray,Œîxs::AbstractArray,prob::HeatProblem;T=1,alg="Euler")
  if length(Œîts)!=length(Œîxs) error("Lengths of Œîts!=Œîxs. Invalid convergence simulation") end
  solutions = DESolution[solve(parabolic_squaremesh([0 1 0 1],Œîxs[i],Œîts[i],T,"Dirichlet"),prob,alg=alg) for i in eachindex(Œîts)]
  auxData = Dict(
            "Œîts" => [sol.femMesh.Œît for sol in solutions],
            "Œîxs" => [sol.femMesh.Œîx for sol in solutions],
            "ŒîŒºs" => [sol.femMesh.Œº  for sol in solutions],
            "ŒîŒΩs" => [sol.femMesh.ŒΩ  for sol in solutions])
  return(ConvergenceSimulation(solutions,auxData=auxData))
end

function testConvergence(Œîxs::AbstractArray,prob::PoissonProblem;alg="Euler")
  solutions = DESolution[solve(notime_squaremesh([0 1 0 1],Œîxs[i],"Dirichlet"),prob) for i in eachindex(Œîxs)]
  auxData = Dict("Œîxs" => [sol.femMesh.Œîx for sol in solutions])
  return(ConvergenceSimulation(solutions,auxData=auxData))
end

"""
length(simres::ConvergenceSimulation)

Returns the number of simultations in the Convergence Simulation
"""
Base.length(simres::ConvergenceSimulation) = simres.N

"""
conv_ests(error::Vector{Number})

Computes the pairwise convergence estimate for a convergence test done by
halving/doubling stepsizes via

log2(error[i+1]/error[i])

Returns the mean of the convergence estimates
"""
function calcùí™estimates(error::Pair)
  key = error.first
  error =mean(error.second,1)
  S = Vector{Float64}(length(error)-1)
  for i=1:length(error)-1
    S[i] = log2(error[i+1]/error[i])
  end
  return(Pair(key,abs(mean(S,1))))
end

"""
conv_ests(error::AbstractArray{Number})

Computes the pairwise convergence estimate for a convergence test done by
halving/doubling stepsizes via

log2(error[i+1]/error[i])

Returns the mean of the convergence estimates
"""
function conv_ests(error::AbstractArray{Float64})
  S = Vector{Float64}(size(error,1)-1,size(error,2))
  for i=1:size(error,1)-1,j=1:size(error,2)
    S[i,j] = log2(error[i+1,j]/error[i,j])
  end
  return(abs(mean(S)))
end
