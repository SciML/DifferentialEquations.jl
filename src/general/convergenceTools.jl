"""
ConvergenceSimulation

A type which holds the data from a convergence simulation.

### Fields

* `solutions::Array{DESolution}`: Holds all the PdeSolutions.
* `h1Errors`: Vector of the H1 errors.
* `l2Errors`: Vector of the L2 errors.
* `maxErrors`: Vector of the nodal maximum errors.
* `node2Errors`: Vector of the nodal l2 errors.
* `N`: The number of simulations.
* `Î”ts`: The Î”t's in the simulations.
* `Î”xs`: The Î”x's in the simulations.
* `Î¼s`: The CFL Î¼'s in the simulations.
* `Î½s`: The CFL Î½'s in the simulations.
* `ConvEst_h1`: The H1 error order of convergence estimate for the convergence simulation.
Generated via `log2(error[i+1]/error[i])`. Thus only valid if generated by halving/doubling
the Î”t/Î”x. If alternate scaling, modify by dividing of log(base,ConvEst_h1)
* `ConvEst_l2`: The L2 error order of convergence estimate for the convergence simulation.
Generated via `log2(error[i+1]/error[i])`. Thus only valid if generated by halving/doubling
the Î”t/Î”x. If alternate scaling, modify by dividing of log(base,ConvEst_l2)
* `ConvEst_max`: The nodal maximum error order of convergence estimate for the convergence simulation.
Generated via `log2(error[i+1]/error[i])`. Thus only valid if generated by halving/doubling
the Î”t/Î”x. If alternate scaling, modify by dividing of log(base,ConvEst_max)
* `ConvEst_node2`: The nodal l2 error order of convergence estimate for the convergence simulation.
Generated via `log2(error[i+1]/error[i])`. Thus only valid if generated by halving/doubling
the Î”t/Î”x. If alternate scaling, modify by dividing of log(base,ConvEst_node2)

"""
type ConvergenceSimulation
  solutions::Array{DESolution}
  errors
  N
  auxData
  ð’ªest
  convergenceAxis
  function ConvergenceSimulation(solutions::Array{DESolution},convergenceAxis;auxData=nothing)
    N = size(solutions,1)
    errors = Dict() #Should add type information
    for k in keys(solutions[1].errors)
      errors[k] = reshape(Float64[sol.errors[k] for sol in solutions],size(solutions)...)
    end
    ð’ªest = Dict(map(calcð’ªestimates,errors))
    for (k,v) in ð’ªest
      if length(v)==1 ð’ªest[k]=v[1] end
    end
    return(new(solutions,errors,N,auxData,ð’ªest,convergenceAxis))
  end
end
function ConvergenceSimulation(solutions::Array{SDESolution},convergenceAxis;auxData=nothing)
  ConvergenceSimulation(convert(Array{DESolution},solutions),convergenceAxis;auxData=auxData)
end

function testConvergence(Î”ts::AbstractArray,prob::SDEProblem;T=1,numMonte=10000,fullSave=true,alg="EM")
  N = length(Î”ts)
  #solutions = DESolution[solve(prob::SDEProblem,Î”ts[i],T,fullSave=fullSave,alg=alg) for j=1:numMonte,i=1:N]
  is = repmat(1:N,1,numMonte)'
  solutions = pmap((i)->solve(prob,Î”ts[i],T,fullSave=fullSave,alg=alg),is)
  solutions = convert(Array{SDESolution},solutions)
  solutions = reshape(solutions,numMonte,N)
  auxData = Dict("Î”ts" =>  Î”ts)
  ConvergenceSimulation(solutions,Î”ts,auxData=auxData)
end

function testConvergence(Î”ts::AbstractArray,Î”xs::AbstractArray,prob::HeatProblem,convergenceAxis;T=1,alg="Euler")
  if length(Î”ts)!=length(Î”xs) error("Lengths of Î”ts!=Î”xs. Invalid convergence simulation") end
  solutions = DESolution[solve(parabolic_squaremesh([0 1 0 1],Î”xs[i],Î”ts[i],T,"Dirichlet"),prob,alg=alg) for i in eachindex(Î”ts)]
  auxData = Dict(
            "Î”ts" => [sol.femMesh.Î”t for sol in solutions],
            "Î”xs" => [sol.femMesh.Î”x for sol in solutions],
            "Î”Î¼s" => [sol.femMesh.Î¼  for sol in solutions],
            "Î”Î½s" => [sol.femMesh.Î½  for sol in solutions])
  return(ConvergenceSimulation(solutions,convergenceAxis,auxData=auxData))
end

function testConvergence(Î”xs::AbstractArray,prob::PoissonProblem;alg="Euler")
  solutions = DESolution[solve(notime_squaremesh([0 1 0 1],Î”xs[i],"Dirichlet"),prob) for i in eachindex(Î”xs)]
  auxData = Dict("Î”xs" => [sol.femMesh.Î”x for sol in solutions])
  return(ConvergenceSimulation(solutions,Î”xs,auxData=auxData))
end

"""
length(simres::ConvergenceSimulation)

Returns the number of simultations in the Convergence Simulation
"""
Base.length(simres::ConvergenceSimulation) = simres.N

"""
conv_ests(error::Vector{Number})

Computes the pairwise convergence estimate for a convergence test done by
halving/doubling stepsizes via

log2(error[i+1]/error[i])

Returns the mean of the convergence estimates
"""
function calcð’ªestimates(error::Pair)
  key = error.first
  error =error.second
  if ndims(error)>1 error=mean(error,1) end
  S = Vector{Float64}(length(error)-1)
  for i=1:length(error)-1
    S[i] = log2(error[i+1]/error[i])
  end
  return(Pair(key,abs(mean(S,1))))
end

"""
conv_ests(error::AbstractArray{Number})

Computes the pairwise convergence estimate for a convergence test done by
halving/doubling stepsizes via

log2(error[i+1]/error[i])

Returns the mean of the convergence estimates
"""
function conv_ests(error::AbstractArray{Float64})
  S = Vector{Float64}(size(error,1)-1,size(error,2))
  for i=1:size(error,1)-1,j=1:size(error,2)
    S[i,j] = log2(error[i+1,j]/error[i,j])
  end
  return(abs(mean(S)))
end
