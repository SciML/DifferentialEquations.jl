"""
ConvergenceSimulation

A type which holds the data from a convergence simulation.

### Fields

* `solutions::Array{DESolution}`: Holds all the PdeSolutions.
* `errors`: Dictionary of the error calculations. Can contain:
  * `h1Errors`: Vector of the H1 errors.
  * `l2Errors`: Vector of the L2 errors.
  * `maxErrors`: Vector of the nodal maximum errors.
  * `node2Errors`: Vector of the nodal l2 errors.
* `N`: The number of simulations.
* `auxData`: Auxillary data of the convergence simluation. Entries can include:
  * `Î”ts`: The Î”t's in the simulations.
  * `Î”xs`: The Î”x's in the simulations.
  * `Î¼s`: The CFL Î¼'s in the simulations.
  * `Î½s`: The CFL Î½'s in the simulations.
* `ð’ªest`: Dictionary of order estimates. Can contain:
  * `ConvEst_h1`: The H1 error order of convergence estimate for the convergence simulation.
  Generated via `log2(error[i+1]/error[i])`. Thus only valid if generated by halving/doubling
  the Î”t/Î”x. If alternate scaling, modify by dividing of log(base,ConvEst_h1)
  * `ConvEst_l2`: The L2 error order of convergence estimate for the convergence simulation.
  Generated via `log2(error[i+1]/error[i])`. Thus only valid if generated by halving/doubling
  the Î”t/Î”x. If alternate scaling, modify by dividing of log(base,ConvEst_l2)
  * `ConvEst_max`: The nodal maximum error order of convergence estimate for the convergence simulation.
  Generated via `log2(error[i+1]/error[i])`. Thus only valid if generated by halving/doubling
  the Î”t/Î”x. If alternate scaling, modify by dividing of log(base,ConvEst_max)
  * `ConvEst_node2`: The nodal l2 error order of convergence estimate for the convergence simulation.
  Generated via `log2(error[i+1]/error[i])`. Thus only valid if generated by halving/doubling
  the Î”t/Î”x. If alternate scaling, modify by dividing of log(base,ConvEst_node2)
* `convergenceAxis`: The axis along which convergence is calculated. For example, if
  we calculate the Î”t convergence, convergenceAxis is the Î”ts used in the calculation.
"""
type ConvergenceSimulation
  solutions::Array{DESolution}
  errors
  N
  auxData
  ð’ªest
  convergenceAxis
  function ConvergenceSimulation(solutions::Array{DESolution},convergenceAxis;auxData=nothing)
    N = size(solutions,1)
    errors = Dict() #Should add type information
    for k in keys(solutions[1].errors)
      errors[k] = reshape(Float64[sol.errors[k] for sol in solutions],size(solutions)...)
    end
    ð’ªest = Dict(map(calcð’ªestimates,errors))
    ð’ªesttmp = Dict() #Makes Dict of Any to be more compatible
    for (k,v) in ð’ªest
      if length(v)==1 push!(ð’ªesttmp,Pair(k,v[1]))
      else push!(ð’ªesttmp,Pair(k,v))
      end
    end
    ð’ªest = ð’ªesttmp
    return(new(solutions,errors,N,auxData,ð’ªest,convergenceAxis))
  end
end
function ConvergenceSimulation(solutions::Array{SDESolution},convergenceAxis;auxData=nothing)
  ConvergenceSimulation(convert(Array{DESolution},solutions),convergenceAxis;auxData=auxData)
end

"""
testConvergence(Î”ts::AbstractArray,prob::SDEProblem)

Tests the strong order time convergence of the given algorithm on the given problem
solved over the given Î”ts.

### Keyword Arguments

* `T`: The final time. Default is 1
* `numMonte`: The number of simulations for each Î”t. Default is 10000.
* `fullSave`: Denotes whether to save at every saveSteps steps. Default is true.
* `saveSteps`: Denotes the steps to save at if `fullSave=true`. Default is 1
* `alg`: The algorithm to test. Defaults to "EM".
"""
function testConvergence(Î”ts::AbstractArray,prob::SDEProblem;tspan=[0,1],numMonte=10000,fullSave=true,saveSteps=1,alg="EM",tableau= constructSRIW1())
  N = length(Î”ts)
  #solutions = DESolution[solve(prob::SDEProblem,Î”ts[i],T,fullSave=fullSave,alg=alg) for j=1:numMonte,i=1:N]
  is = repmat(1:N,1,numMonte)'
  solutions = pmap((i)->solve(prob,tspan,Î”t=Î”ts[i],fullSave=fullSave,saveSteps=saveSteps,alg=alg,tableau=tableau),is)
  solutions = convert(Array{SDESolution},solutions)
  solutions = reshape(solutions,numMonte,N)
  auxData = Dict("Î”ts" =>  Î”ts)
  ConvergenceSimulation(solutions,Î”ts,auxData=auxData)
end

"""
testConvergence(Î”ts::AbstractArray,prob::ODEProblem)

Tests the order of the time convergence of the given algorithm on the given problem
solved over the given Î”ts.

### Keyword Arguments

* `T`: The final time. Default is 1
* `fullSave`: Denotes whether to save at every saveSteps steps. Default is true.
* `saveSteps`: Denotes the steps to save at if `fullSave=true`. Default is 1
* `alg`: The algorithm to test. Defaults to "Euler".
* `tableau`: The tableau used for generic methods. Defaults to DEFAULT_TABLEAU.
"""
function testConvergence(Î”ts::AbstractArray,prob::ODEProblem;tspan=[0,1],fullSave=true,alg="Euler",saveSteps=1,tableau=DEFAULT_TABLEAU)
  N = length(Î”ts)
  solutions = DESolution[solve(prob::ODEProblem,tspan,Î”t=Î”ts[i],fullSave=fullSave,alg=alg,saveSteps=saveSteps,tableau=tableau) for i=1:N]
  auxData = Dict("Î”ts" =>  Î”ts)
  ConvergenceSimulation(solutions,Î”ts,auxData=auxData)
end

"""
testConvergence(Î”ts::AbstractArray,Î”xs::AbstractArray,prob::HeatProblem,convergenceAxis)

Tests the convergence of the solver algorithm on the given Heat problem with
the Î”ts and Î”xs as given. Uses the square mesh [0,1]x[0,1]. The convergence
axis is the axis along which convergence is calculated. For example, when testing
Î”t convergence, `convergenceAxis = Î”ts`.

### Keyword Arguments

* `T`: The final time. Defaults to 1
* `alg`: The algorithm to test. Default is "Euler".
"""
function testConvergence(Î”ts::AbstractArray,Î”xs::AbstractArray,prob::HeatProblem,convergenceAxis;T=1,alg="Euler")
  if length(Î”ts)!=length(Î”xs) error("Lengths of Î”ts!=Î”xs. Invalid convergence simulation") end
  solutions = DESolution[solve(parabolic_squaremesh([0 1 0 1],Î”xs[i],Î”ts[i],T,"Dirichlet"),prob,alg=alg) for i in eachindex(Î”ts)]
  auxData = Dict(
            "Î”ts" => [sol.femMesh.Î”t for sol in solutions],
            "Î”xs" => [sol.femMesh.Î”x for sol in solutions],
            "Î”Î¼s" => [sol.femMesh.Î¼  for sol in solutions],
            "Î”Î½s" => [sol.femMesh.Î½  for sol in solutions])
  return(ConvergenceSimulation(solutions,convergenceAxis,auxData=auxData))
end

"""
testConvergence(Î”xs::AbstractArray,prob::PoissonProblem)

Tests the convergence of the solver algorithm on the given Poisson problem with
Î”xs as given. Uses the square mesh [0,1]x[0,1].

### Keyword Arguments

* `solver`: Which solver to use. Default is "Direct".
"""
function testConvergence(Î”xs::AbstractArray,prob::PoissonProblem)
  solutions = DESolution[solve(notime_squaremesh([0 1 0 1],Î”xs[i],"Dirichlet"),prob,solver="Direct") for i in eachindex(Î”xs)]
  auxData = Dict("Î”xs" => [sol.femMesh.Î”x for sol in solutions])
  return(ConvergenceSimulation(solutions,Î”xs,auxData=auxData))
end

"""
length(simres::ConvergenceSimulation)

Returns the number of simultations in the Convergence Simulation
"""
Base.length(simres::ConvergenceSimulation) = simres.N

"""
conv_ests(error::Vector{Number})

Computes the pairwise convergence estimate for a convergence test done by
halving/doubling stepsizes via

log2(error[i+1]/error[i])

Returns the mean of the convergence estimates
"""
function calcð’ªestimates(error::Pair)
  key = error.first
  error =error.second
  if ndims(error)>1 error=mean(error,1) end
  S = Vector{Float64}(length(error)-1)
  for i=1:length(error)-1
    S[i] = log2(error[i+1]/error[i])
  end
  return(Pair(key,abs(mean(S,1))))
end

"""
conv_ests(error::AbstractArray{Number})

Computes the pairwise convergence estimate for a convergence test done by
halving/doubling stepsizes via

log2(error[i+1]/error[i])

Returns the mean of the convergence estimates
"""
function conv_ests(error::AbstractArray{Float64})
  S = Vector{Float64}(size(error,1)-1,size(error,2))
  for i=1:size(error,1)-1,j=1:size(error,2)
    S[i,j] = log2(error[i+1,j]/error[i,j])
  end
  return(abs(mean(S)))
end
